% Vorlage fuer eine Studien- oder Diplomarbeit mit LaTeX
%
% Lehrstuhl fuer VWL, Technische Universitaet Muenchen
%
%
% Diese Vorlage benutzt kein bibtex.
% Wer moechte, kann eine eigene Literaturdatenbank anlegen:
%  literatur.bib   (Literaturverzeichnis im BibTeX-Format)
%
% Ausserdem werden folgende Dateien benoetigt (muessen _nicht_
% geaendert werden!):
% ./einstell.tex   (allgemeine Einstellungen wie Seitengroesse etc.)
% ./TUM_Logo.pdf (TUM-Logo fuer das Titelblatt)
% ./Institutslogo.png (Instituts-Logo fuer das Titelblatt)
% ./dummy.pdf (dient nur zu Demonstrationszwecken und kann spaeter entfernt werden)
% ./psfig.sty
%

\input{einstell} % Stil- und Layoutdefinitionen

\begin{document}

\begin{titlepage}
\voffset-40mm
  \parbox{1.5cm}{\resizebox*{110pt}{!}{\includegraphics{TUM_Logo.pdf}}}\hspace{310pt}%
  \parbox{1.5cm}{\resizebox*{63pt}{!}{\includegraphics{Institutslogo.png}}}%
\vspace*{1.5cm}
\begin{center}

{\Huge Technische Universit\"at M\"unchen} 
\\
\vspace*{1cm}
{\huge \sc{ TUM School of Management}} 
\\ 
\vspace*{2cm}
{\Huge {\bf Interdisciplinary Project}}\\
\vspace*{1cm}
{\Large {\bf Programming on a web-based platform for conducting experiments using the example of dynamic bank runs }}\\
\vspace*{4cm}
{ 
\begin{tabular}{ll}
Supervisor: & Univ.-Prof. Dr. Robert K. Frhr. von Weizs\"{a}cker \\
			& Lehrstuhl f\"{u}r Volkswirtschaftslehre\\
			& Finanzwissenschaft und Industrie\"{o}konomik\\
			& Technische Universit\"{a}t M\"{u}nchen \vspace*{0.3cm} \\ 
Advisor: & M.Sc. Christoph Gschnaidtner 		\vspace*{0.3cm}  \\
Graduate program: & Informatics		\vspace*{0.3cm} \\ 
Author: & Ozan Pekmezci \\
		& Steinickeweg 7 App 313 80798 Munich \\
		& 03636264 \vspace*{0.3cm} \\
Submission date: & 01. April 2017
\end{tabular}
}

\end{center}
\end{titlepage}




\thispagestyle{plain}
\vspace*{11cm}
\noindent
I hereby declare that the documentation submitted is my own unaided work. All direct or indirect sources used are acknowledged as references. \\

I am aware that the documentation in digital form can be examined for the use of unauthorized aid and in order to determine whether the documentation as a whole or parts incorporated in it may be deemed as plagiarism. For the comparison of my work with existing sources I agree that it shall be entered in a database where it shall also remain after examination, to enable comparison with future theses submitted. Further rights of reproduction and usage, however, are not granted here.\\
 
This paper was not previously presented to another examination board and has not been published. \\\\\\\\

M\"{u}nchen, 01. April 2017

\newpage

%Seitennummerierung "roemisch
\pagenumbering{roman}\setcounter{page}{0} %Seite vor Inhaltsverzeichnis nicht nummeriert
%Kopfzeilen (automatisch erzeugt)
\pagestyle{headings}


\tableofcontents      %  Inhaltsverzeichnis

\addcontentsline{toc}{chapter}{List of Figures}
\listoffigures

\addcontentsline{toc}{chapter}{List of Tables} 
\listoftables
 
 

\pagenumbering{arabic}
 


\chapter{Introduction } \label{cha:einleitung}

//TODO

This is a project to program an experiment 

\section{Introduction to oTree}\label{sec:intro}

oTree is an open-source framework that is designed to do interactive experiments on economics. It is based on Django which is a web framework that is designed for Python programming language.

\begin{figure}[h]
	\centerline{\psfig{figure=django_mvc_mvt_pattern.jpg,width=120mm}}
	\caption{Abstraction of MVT Pattern[\cite{DjangoOverview2017}]}
	\label{fig:picture2}
	
\end{figure}

The design pattern used by Django and also by oTree is \verb|MVT| [\cite{DjangoOverview2017}]. MVT means \verb|model-view-template| and that terminology explains what types of components the application consists of[\ref{fig:picture2}].  

This pattern explains that there is a model component that is responsible for the backend in general. It generates the database fields and it is responsible for the business logic. It does the calculations etc.

The template component consists of multiple html files that are called by the view. It determines how the page should look like and what the page shows.

The view on the other hand is a connection between model and template. It sends the template the required variables and also receive some information from the model. It is responsible for the working sequence of the application.

\section{Concepts}

\begin{figure}[h]
	\centerline{\psfig{figure=oTreeConcepts.png,width=120mm}}
	\caption{Conceptual Overview of oTree[\cite{oTreeConcepts2017}]}
	\label{fig:picture3}
	
\end{figure}

\subsection{Session}

A session can be thought as an whole experiment. It can consist of many subsessions. For example, a session can be a public goods game plus a questionnaire[\cite{oTreeConcepts2017}].

\subsection{Subsession}

Subsessions are parts of the session as the name suggests. In the above example, public goods game is one subsession and the questionnaire is another subsession. Each subsession have multiple pages that is going to be explained in the views part[TODO page cite]

\begin{figure}[h]
	\centerline{\psfig{figure=objectHierarchy.png,width=60mm}}
	\caption{Object Hiearchy of oTree[\cite{oTreeConcepts2017}]}
	\label{fig:picture4}
	
\end{figure}

\subsection{Group}

A group consists of players that are taking part in the same subsession of the session. Therefore, a subsession is divided into a groups of players[Figure \ref{fig:picture4}].

\begin{figure}[h]
	\centerline{\psfig{figure=participant.png,width=120mm}}
	\caption{Concept of Participant explained[\cite{oTreeConcepts2017}]}
	\label{fig:picture5}
	
\end{figure}

\subsection{Participant and Player}\label{sub:participant}

Player in oTree is just an instance of the concept Participant. There is a different Player instance for every round and for each real-life player. These instances can have different payoffs and different attributes. However, each real-life player have one participant for each subsession and her attributes stay the same for the whole subsession[Figure \ref{fig:picture5}].

\begin{figure}[h]
	\centerline{\psfig{figure=object_model_self.png,width=120mm}}
	\caption{Reachable objects via self[\cite{oTreeConcepts2017}]}
	\label{fig:picture6}
	
\end{figure}

\subsection{self}

As the readers check out the code, they will see the variable self very often. It is a Python-spefic instance that describes the context and can be compared to \verb|this| in Java programming language. oTree functions will mostly expect self as a parameter and these functions can be called by command \verb|self.functionName()|.

This means that if the method accepts self in the \verb|Page| class, self refers to the Page object. Since the class Page is a subclass of the \verb|Player| class[Figure \ref{fig:picture4}],  Player can be referenced with \verb|self.player|. This logic is also explained in Figure \ref{fig:picture6}. Subclasses can refer to their superclasses but the opposite doesn't work. Extra to that, Player can refer to \verb|Participant| class via self, that is also explained in the subsection \ref{sub:participant}. 

Furthermore, there are also many cases that the developers can refer from superclass to subclass. However, it is a bit different and can be explained easier with an example. Every player is part of only one group but each group consists of multiple players. That's why it is easy to refer to the group just by saying \verb|self.group|, but players in a group need to be referred with \verb|self.get_players()|, that will return a list of players. There are many similar examples on the official documentation of oTree [\cite{oTreeConcepts2017}]. 

\section{Components}

\subsection{Model}

The model conponent of MVT[Section \ref{sec:intro}] pattern is programmed in the file \verb|models.py|. The file contains four classes: \verb|Constants, Subsession, Group and Player| 

Constants class is the place that put variables that don't ever change in the game. The class has three required fields, which are \verb|name_in_url, players_per_group and num_rounds|. \verb|name_in_url| is the name of the the app that is going to appear on the url. \verb|players_per_group| defines how many players can be in each group. If it has the value \verb|None|, all of the players will be in the same group. \verb|num_rounds| describes the amount of rounds that the experiment will go on. It needs to have a static integer value. Constant values should never be modified to prevent unexpected behaviour[\cite{oTreeModel2017}]. 

\begin{figure}[h]
	\centerline{\psfig{figure=before_session_starts.png,width=120mm}}
	\caption{An example usage of the method[\cite{oTreeModel2017}]}
	\label{fig:picture7}
	
\end{figure}

In the context of oTree, subsession actually means a round. Therefore, this class contains round-specific information. Its method \verb|before_session_starts| is important because it is the recommeded place to prepare and assign data to  player for each round. However, it must be noted that this method is called once for each round \verb|before the session starts|. That's why no developers shouldn't use variables that change during the game.  A typical usage is looping through players and doing some operations for them[Figure \ref{fig:picture7}].

\begin{figure}[h]
	\centerline{\psfig{figure=playerModel.png,width=120mm}}
	\caption{Player class of bank run experiment}
	\label{fig:picture8}
\end{figure}

Model file also contains fields for the classes that are used to generate database columns for select tables. There are some special types of fields that are inherited from Django can be used on the starting lines of classes. The field \verb|models.CharField()| can be used for strings, \verb|models.FloatField()| for floats(real decimal numbers), \verb|models.BooleanField()| for boolean values, \verb|models.IntegerField()| and \verb|models.PositiveIntegerField()| for integers. oTree also supports an extra field \verb|models.CurrencyField()| for currencies [Figure \ref{fig:picture8}]. 

\begin{figure}[h]
	\centerline{\psfig{figure=page_sequence.png,width=60mm}}
	\caption{Page sequence list of bank run experiment}
	\label{fig:picture9}
\end{figure}

\subsection{View}

As it was explained in the introduction part of oTree[\ref{sec:intro}],the view component takes care of the application sequence. It also the connector between model and template. The view file contains a class for each page that  will appear and the sequence of these pages are stated in the \verb|page_sequence| list in desired order[Figure \ref{fig:picture7}]. Pages can be divided into two general categories. They are pages and wait pages. Page classes expect the argument type \verb|Page| and wait pages expect the argument type \verb|WaitPage|.

\begin{figure}[h]
	\centerline{\psfig{figure=page.png,width=120mm}}
	\caption{A Page class of the bank run experiment}
	\label{fig:picture10}
\end{figure}

\subsubsection{Page}

Pages contain information about the code that is going to run on client-side(users browser). Pages can describe the form that is shown on the page and can connect the server-side implementation of the form with the client-side implementation. These get set with \verb|form_model and form_fields| variables[Figure \ref{fig:picture10}].

There are also other attributes that can be used inside the page classes. For example, if user wants to set a timeout for users to respond to the form, developers can use \verb|timeout_seconds and timeout_submission| variables. Former one sets the maximal time to respond in seconds and the latter one decides what is going to happen if the user doesn't response in the desired time.

Page classes can also contain some methods that are useful for many applications. One of them is \verb|is_displayed(self)|; it determines in which condition users see the page. \verb|vars_for_template(self)| method returns some custom variables to the template, \verb|before_next_page(self)| method gives developer the option to do some operations after user responds to the form and navigates to the next page.

\subsubsection{Wait Page}

Wait Pages are used to make sure users start each part of the experiment at the sime time. Users that respond fast wait until the others respond to that form as well. Users see a loading page while waiting. An important method of the wait page class is \verb|after_all_players_arrive(self)|. This determines what to do when all players reach the desired wait page. It can be used to call some functions in the models file. Developers can also choose to customize the appereance of the wait page[\cite{oTreeView2017}].

\begin{figure}[h]
	\centerline{\psfig{figure=html.png,width=120mm}}
	\caption{Some code sample of a HTML file[\cite{DjangoTemplate2017}].}
	\label{fig:picture10}
\end{figure}

\subsection{Template}

Templates are coded in html files and oTree uses Django's template language[\cite{DjangoTemplate2017}]. HTML code can be written on the files directly but python code can be written in a different format. Variables can be used in double brackets(\verb|{{example}}|). Tags like \verb|for loops, if clauses| are written between brackets and percent signs [Figure\ref{fig:picture10}]. 

\section{Introduction to Bank Runs}

Banks that use fractional-reserve-banking system store only a small fraction of their assets as cash. However, this can be problematic if many people try to withdraw money in a short time. When more people withdraw money and withdrawing gains a momentum for some reason, bank can run out of cash and go bankrupt [\cite{Diamond2007}]. At this point money of everybody that deposited to the bank is gone. 

To prevent that, banks may limit the money to withdraw or just cancel withdrawing for some time. This text is the documentation of a platform that is aiming to experiment how these bank runs happen.

The starting point of this project are the empirical studies that are conducted to test predictions of theoretical models and investigate the behaviour of people during withdrawal process. One of the empirical studies that is reviewed and tested by the author is  \verb|The Madies Study| [\cite{Madies2007}].

\subsection{The Madies Study}\label{sub:madies}

Madies sets an experiment environment with some defined amount of participants, periods, amount to withdraw and an upper limit for bankruptcy. Participants are  people that take part in the experiment, periods mean withdrawing the money earlier or later, amount to withdraw differentiate between periods and bank going bankrupt. Lastly, upper limit is the amount of withdrawing people that make the bank go bankrupt. The time model of this experiment is discrete meaning that participants do actions simultaneously.

\begin{figure}[h]
	\centerline{\psfig{figure=madies.png,width=120mm}}
	\caption{Visualisation of the Madies Study[\cite{Madies2007}]}
	\label{tab:tabellenreferenz2}
	
\end{figure}


The game is played for thirty rounds and in each round participants are asked if they want to withdraw in period one or two. Advantage of withdrawing on period 1 is the fact that the participants have higher chance to be able to withdraw their money. However, if they choose to withdraw their money on period 2, they will get their money plus interest if the bank didn't go bankrupt before[Figure \ref{tab:tabellenreferenz2}].

In this particular environment, bank goes bankrupt if four or more people withdraws in period 1. First three participants can withdraw 40 unit currency and the rest get 0. In the bankruptcy case, participants that choose period 2 can't withdraw any money. If three or less participants choose to withdraw on period 1, they all get 40 unit currency in period 1 and the rest get 45 unit currency in period 2.

The problem with this study are the facts that, participants can only withdraw a static amount of money and bank goes bankrupt depending on amount of people instead of  money amount. These drawbacks are considered and imporoved in our experiment which is explained in the next chapter.


%
\iffalse

\section{Abschnittsname 2}

Ein weiterer Abschnitt.

\subsection{Ein Unterabschnitt}

Dies ist der erste Unterabschnitt des zweiten Abschnittes. Auf jeder Gliederungsebene m\"ussen mindestens zwei Punkte verortet sein. Also: kein 2.2.1 ohne 2.2.2! Deswegen folgt nun ...

\subsection{Ein weiterer Unterabschnitt}

Verweise auf Bilder (vgl. Bild \ref{fig:bildreferenz1}), Tabellen (vgl. Tabelle \ref{tab:tabellenreferenz1}) oder Literaturangaben (vgl. \cite{sharpe1964}) wie hier angegeben. Es k\"onnen auch mehrere Literaturangaben gleichzeitig zitiert werden, vgl. \cite{sharpe1964, xyz2008}.

Ein Bild wird folgenderma\ss{}en eingebunden:

\begin{figure}[h]
  \centerline{\psfig{figure=dummy.pdf,width=120mm}}
  \caption{Bildbeschriftung}
  \label{fig:bildreferenz1}
\end{figure}

Nat\"urlich kann auch eine Tabelle eingef\"ugt werden:
\begin{table}[htbp]
	\caption{Tabellenname.}
	\centering
		\begin{tabular}{|l|c|c|}
			\hline
			 & Spalte 1 & Spalte 2\\
			 \hline
			 Zeile 1 & Eintrag 1,1 & Eintrag 1,2\\
			 \hline
			 Zeile 2 & Eintrag 2,1 & Eintrag 2,2\\
			 \hline			
		\end{tabular}
	\label{tab:tabellenreferenz1}
\end{table}
%
\fi


\chapter{Bank Run Experiment} \label{cha:bankRunExperiment}

The aim of this project is experimenting with the oTree framework and test how it actually works. The topic of bank runs is chosen as en example for it. 

Bank run experiment can be done in different settings or environments. In this one we want to use variables rather than constants. This means that we want to have modifiable number of player, rounds, thresholds etc. 

The main logic is similar to the Madies Study which is an empirical study for bank runs [Section \ref{sub:madies}]. It has some more extra features that are going to explained in the upcoming sections.

\section{Setting and Environment}

Like it is said above, the bank run experiment uses as many changeable values as possible to give flexibility to the experimenters. Experimenters can find the optimal values to make correct observations. 

This experiment simulates people that have a starting amount that is determined by the experimenter. However, all of the participants receive the same starting money. Participants can store their money in a risk-free investment or they can choose to put their money on the bank. Storing money in the investment has the advantage of not getting affected by a possible bankruptcy but depositing money to the bank gives you an interest per round. The interest is determined by the experimenter as well. 

The game is played until the bank goes bankrupt or the last round is reached. The last round of the game is also set by the experimenter but it must be greater than two because the first round of the experiment is deciding if participants want to deposit money on a investment or to the bank. Starting from second round, participants decide if they want to keep their money at the bank or  withdraw it. Some participants are forced to withdraw money from the bank. This is totally random and the experimenter can decide the percent of participants that will be forced to withdraw. Experimenters can also decide how much money that the chosen participants need to withdraw minimally. 

If threshold of withdrawals is reached, the bank goes bankrupt and the game ends. This threshold can also be set by the experimenter. It is given as a percentage and the threshold is calculated by the multiplication of the percantage and total money that is deposited to the bank at the beginning of the game. 

oTree has built-in support of changeable participant value. No extra work is done for that. Lastly, experimenters can also choose between allowing to watch others or not. If its allowed, users can see current information about other users at the end of each round. Else, they can only see this information when the game ends.

\section{oTree Platform}

Initially, the experiment was planned to be played continuously instead of being discrete. According to the plan, game would have no rounds. Meaning that, users would be able to deposit or withdraw anytime and the application would react accordingly. However, continuous-time games were not part of oTree as of 2017 but the oTree team have stated that they plan to add this feature in the future[\cite{oTreeSlides2007}]. That's why the developer of this project enabled withdrawing dynamic amount of money. The game also has non-static number of rounds in contrast to the Madies Study[Section \ref{sub:madies}].

\begin{figure}[h]
	\centerline{\psfig{figure=minValue.png,width=120mm}}
	\caption{Form from bank run doesn't allow negative values }
	\label{tab:tabellenreferenz11}
	
\end{figure}

Withdrawals of dynamic values are trivial in oTree, since it requires only one \verb|models.CurrencyField| field in models file and corresponding form fields in the view[Section \ref{sec:intro}]. CurrencyField can accept parameters for minimum and maximum values, which limits users for entering amounts in the desired range. This is really useful because this limitation occurs on the client-side and form only gets submitted when user enters a "correct" value. Problem is the fact that these min and max arguments can only be static values since the code is executed on the setup phase. That's why developers can't set arguments that depend on other values. In the context of  bank run experiment, it was aimed to have a limitation between zero and the money that participant deposited before. Unfortunately, the developer couldn't set a max value because it would depend on the money at bank. Therefore, form accepts any value that is positive and the program limits unallowed entries on the backend[Figure \ref{tab:tabellenreferenz11}]. 

It was also important for the experiments to have dynamic number of rounds. The two round system of the Madies Study is limited and doesn't allow much of a difference. However, it could be meaningful for the experimenters to see difference between the participant reactions in different cases. That's why the bank run experiment has variable number of rounds and experiment ends when the bank goes bankrupt or the desired number of rounds is reached. Sadly, oTree needs a static number for number of values in the \verb|Constants| class[Section \ref{sec:intro}]. oTree needs that number, because the framework prepares the models before the game actually starts. It loops for each user and for each round. Only solution is actually a "hack" in computer science terms but it is also recommended on the official oTree documentation, so it is applied by the author of this text as well[\cite{oTreeModel2017}]. This method is setting the number of rounds to a big random value(\verb|30| in our experiment). When the actually desired round number is reached, application hides the \verb|next|button for the participants.

Most of the example projects for oTree don't have the concept of a storage like in the bank run experiment. Some of them have some kind of money pool but none of them have a concept similar to personal bank accounts. The basic principle of oTree experiments consist of the calculation of the \verb|payoff| for each player and each round. In the end, sum of these payoffs are the final results. However, we have two distinct values for each player. These are money at hand and money at bank. They can't be merged together because money at bank can gain interest and also it can be nulled in case of bankruptcy. That's why, participant dictionary is used to store these two crucial values[Section \ref{sub:participant}]. Parcitipant dictionary stays same for the participant throughout the game but player fields change in each round. For example, money at hand can be reached with the \verb|player.participant.vars["money_at_hand"]| for each participant.

A last concept that influenced the design of the software is the method \verb|before next page|. It is located in the 

\section{Workflow}

session yaratilir, setting secilir, sunu görür su metod falan



\chapter{Bank Run Experiment Results} \label{cha:bankrunResults}

\chapter{Future Work and Conclusion}

\section{Evaluation of oTree Framework}

% --- Falls Anhaenge gewuenscht werden: ---
\begin{appendix} \label{anhang}
\chapter{Installing oTree} \label{anhang1}

\section{Installing Python}

This sections explains how to install Python on different operating systems. 

\subsection{Installing Python on Windows}

Windows users can install Python with the setup file that can be downloaded from \verb|https://www.python.org/downloads/release/python-360/|. Users 
need to choose marked fields(\ref{fig:picture1}) and the installer will install both python and required tool \verb|pip| to download other packages.

\begin{figure}[h]
	\centerline{\psfig{figure=py-win-installer.png,width=120mm}}
	\caption{Python Installation Screen on Windows}
	\label{fig:picture1}
\end{figure}


After that users can navigate to  \verb|PowerShell| application and test the installation by typing  \verb|pip3 -V|. If it shows the right version number, user download other packages etc.


\subsection{Installing Python on Mac}

The official oTree documentation recommends using \verb|Homebrew| package manager on MacOS to install Python. However, mac users need to install \verb|Command line developer tools| first, which is going to install many essential libraries and programs to start developing on mac. After that users can download Homebrew and lastly install Python. Users can test the installation by typing \verb|pip3 -V| on the Terminal just like on Windows [\cite{oTreeInstall2017}].

\subsection{Installing Python on Linux}

Python can be installed easily on a Debian/Ubuntu based Linux distribution by typing the command \verb|sudo apt-get install python3-pip| on Terminal. The installation can also tested with the same command like on other operating systems.

\section{Installing oTree}

Users can install otTree easily by typing the command \verb|pip3 install -U otree-core| on Powershell(for Windows) or on Terminal for Unix based operating systems. The same command is also used to upgrade the oTree versions in the future.

\section{Running oTree}

Users that run oTree for the first time need to type in the command \verb|otree startproject oTree|, which will generete an \verb|oTree| folder containing necessary files and example projects. After that users can navigate to the newly generated folder by using the command \verb|cd oTree|. 

When you are in the right folder, users first need to migrate and reset the database. This is done with the command \verb|otree resetdb| and it needs to be applied everytime when there is a change in the model file[TODO: citation model file]. Finally, users can run the server with command \verb|otree runserver|. To stop the server, pressing on both \verb|ctrl and c| keys is enough. On the same terminal tab, oTree states the local address that the oTree is running on, which is mostly \verb|http://127.0.0.1:8000/|. Users can visit this link on their own browser.

\section{The Development Environment}

Although Python code can be written on any text editor even on Terminal, the IDE \verb|PyCharm| is recommended by both the official documentation and the author of this documentation. It provides autocompletion and also makes it much harder to make errors. PyCharm has both free and paid versions but students or teachers(including teaching assistants) can get the paid version for free. The paid version features Django support that the oTree is built on. Developers just need to import the oTree folder, enable Django support on the settings and set the root folder of oTree as \verb|Django project root |. 

\section{Troubleshooting}

\subsection{Developer needs to have multiple python versions installed}

Some developers may have an issue that they need to have a one specific Django/Python version for a not oTree related project and another one for the oTree. In that case users won't be able to run one of the projects or they will need to install/uninstall every time. However, there is a solution for that. 

Developers can install the Python package \verb|virtualenv| just with \verb|pip install virtualenv| command. Like the name suggests, this little program creates virtual environments for each folder structure so that users can install different python/Django or any other package without interfering with each other. To use it, developers must navigate to the desired folder and type the command \verb|virtualenv env| which will create the environment \verb|env| folder. After that developers need to type the code \verb|source env/bin/activate| every time they want to run the environment. 

\subsection{Developer needs to use dictionary values in template files}

\subsection{Developers need to have custom number of rounds}

\section{Erster Teil des Anhangs}

\section{Zweiter Abschnitt dieses Anhangs}

\end{appendix}

% --- Und vielleicht noch ein Abbildungsverzeichnis ... ---



% --- Das Literaturverzeichnis: ---

\begin{thebibliography}{XX}
	
\bibitem[oTree (2016)]{oTree2016} Chen, D.L., Schonger, M., Wickens, C., 2016. oTree - An open-source platform for laboratory, online and field experiments. Journal of Behavioral and Experimental Finance, vol 9: 88-97

\bibitem[Heston (1993)]{Heston1993} Heston, S. (1993). A closed-form solution for options with stochastic volatility with applications to bond and currency options.
The Review of Financial Studies, Volume 6, Issue 2, pp. 327-343

\bibitem[Sharpe(1964)]{sharpe1964} Sharpe, W. (1964). Capital Asset Prices -- A Theory of Market Equilibrium Under Conditions of Risk. Journal of Finance, Vol. 19, pp. 77-91

\bibitem[oTree(2017)]{oTree2017} oTree. (2017). Official Documentation of oTree, \verb|otree.readthedocs.io|

\bibitem[oTree Installation(2017)]{oTreeInstall2017} oTree. (2017). Official Documentation of oTree,\\ \verb|otree.readthedocs.io/en/latest/install.html|

\bibitem[Django Overview(2017)]{DjangoOverview2017} Tutorialspoint. (2017). Django Tutorial,\\ \verb|https://www.tutorialspoint.com/django/django_overview.htm|

\bibitem[oTree Concepts(2017)]{oTreeConcepts2017} oTree. (2017). oTree Concepts,\\ \verb|http://otree.readthedocs.io/en/latest/conceptual_overview.html|

\bibitem[oTree Model(2017)]{oTreeModel2017} oTree. (2017). oTree Model,\\ \verb|http://otree.readthedocs.io/en/latest/models.html|

\bibitem[oTree View(2017)]{oTreeView2017} oTree. (2017). oTree View,\\ \verb|http://otree.readthedocs.io/en/latest/view.html|

\bibitem[Django Template(2017)]{DjangoTemplate2017} Django. (2017). Django Template,\\ \verb|https://docs.djangoproject.com/en/1.8/ref/templates/language/|

\bibitem[Diamond (2007)]{Diamond2007} Diamond, D. (2007). Banks and Liquidity Creation: A Simple Exposition of the Diamond-Dybvig Model 
Economic Quarterly, Volume 93, Number 2, pp. 189-200

\bibitem[Madies (2007)]{Madies2007} Philippe Madi`es. Self-fulfilling bank panics : how to avoid them ? an experimental study.
Working Paper du GATE 2001-04. 2001. <halshs-00179997>

\bibitem[oTree Slides(2007)]{oTreeSlides2007} Chris. oTree:An open-source platform for lab,web and field experiments.


\end{thebibliography}


\end{document}
